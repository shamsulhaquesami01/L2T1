üî• ADVANCED SQL EXAM CHEAT SHEET (HR Schema)

> Purpose: One-stop resource you can carry into the lab exam.
Covers ALL tricky patterns, logical traps, and frequently asked SQL constructs.




---

1Ô∏è‚É£ AGGREGATES & AVERAGES (Core Patterns)

üîπ Salary > Department Average

select e.first_name, e.salary
from employees e
where e.salary > (
    select avg(e2.salary)
    from employees e2
    where e2.department_id = e.department_id
);

üîπ Salary > Company Average

where salary > (select avg(salary) from employees)


---

2Ô∏è‚É£ HIGHEST / LOWEST SALARY PROBLEMS

üîπ Highest Salary in Each Department (JOIN ONLY ‚Äì examiner favorite)

select e.*
from employees e
left join employees x
  on e.department_id = x.department_id
 and x.salary > e.salary
where x.employee_id is null;

üîπ Lowest Salary in Each Department

select e.*
from employees e
left join employees x
  on e.department_id = x.department_id
 and x.salary < e.salary
where x.employee_id is null;


---

3Ô∏è‚É£ SECOND HIGHEST SALARY (IMPORTANT)

üîπ Second Highest Salary in Each Department (by VALUE)

select e.*
from employees e
where 1 = (
    select count(distinct e2.salary)
    from employees e2
    where e2.department_id = e.department_id
      and e2.salary > e.salary
);

‚úî Handles ties correctly


---

4Ô∏è‚É£ RANKING (SUBQUERY ONLY)

üîπ RANK() behavior (1,2,2,4)

select e.last_name,
       (select count(*) from employees x where x.salary > e.salary) + 1 as rnk
from employees e;

üîπ DENSE_RANK() behavior (1,2,2,3)

select e.last_name,
       (select count(distinct x.salary) from employees x where x.salary > e.salary) + 1 as drnk
from employees e;


---

5Ô∏è‚É£ EXISTS / NOT EXISTS / NOT IN (TRAPS)

üîπ Employees NOT in JOB_HISTORY (SAFE)

select *
from employees e
where not exists (
    select 1 from job_history j
    where j.employee_id = e.employee_id
);

‚ö†Ô∏è NOT IN TRAP (NULL kills result)

-- ‚ùå avoid if subquery can return NULL
where employee_id not in (select employee_id from job_history)


---

6Ô∏è‚É£ AT LEAST / EVERY / EXACTLY CONDITIONS

üîπ Managers with AT LEAST 3 employees

where 3 <= (
    select count(*) from employees e2
    where e2.manager_id = e.manager_id
)

üîπ EVERY employee satisfies condition

-- total = qualified
total_count = qualified_count

üîπ EXACTLY ONE (XOR)

(A or B) and not (A and B)


---

7Ô∏è‚É£ COUNT-BASED LOGIC TRICKS

üîπ Departments with more than 5 employees

where 5 < (
    select count(*) from employees e2
    where e2.department_id = e.department_id
)

üîπ Departments with NO employees

where not exists (
    select 1 from employees e2
    where e2.department_id = d.department_id
)


---

8Ô∏è‚É£ SET OPERATIONS (NO AND / OR / NOT)

üîπ Combine current + past jobs

select employee_id, count(distinct job_id)
from (
    select employee_id, job_id from employees
    union
    select employee_id, job_id from job_history
)
group by employee_id;


---

9Ô∏è‚É£ SELF JOIN ESSENTIALS

üîπ Employees in same department

select e1.employee_id, e2.employee_id
from employees e1
join employees e2
  on e1.department_id = e2.department_id
 and e1.employee_id <> e2.employee_id;


---

üîü JOIN THEORY (MEMORIZE)

Join Type	Meaning

INNER JOIN	Matching rows only
LEFT JOIN	All left + matched right
RIGHT JOIN	All right + matched left
ANTI JOIN	left join + is null



---

1Ô∏è‚É£1Ô∏è‚É£ GROUP BY + HAVING (FILTER GROUPS)

select department_id
from employees
group by department_id
having avg(salary) > (select avg(salary) from employees);


---

1Ô∏è‚É£2Ô∏è‚É£ COMMON EXAM MISTAKES ‚ùå

‚ùå Using count(*) instead of count(distinct) ‚ùå Forgetting parentheses with AND / OR ‚ùå Using NOT IN with NULLs ‚ùå Confusing RANK vs DENSE_RANK ‚ùå Using WHERE instead of HAVING


---

üß† FINAL MEMORY RULES

‚Ä¢ "Every" ‚áí total = qualified
‚Ä¢ Second highest ‚áí count(distinct salary > current)
‚Ä¢ NOT EXISTS > NOT IN
‚Ä¢ Gaps needed ‚áí RANK logic
‚Ä¢ No gaps ‚áí DENSE RANK logic


---

‚úÖ If you can understand every block here, you will not lose marks in advanced SQL lab.